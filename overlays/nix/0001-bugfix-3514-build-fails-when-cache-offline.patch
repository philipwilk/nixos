From 6398a0687567d3cd5410e5b7dc716bdeb5bace45 Mon Sep 17 00:00:00 2001
From: Philip Wilk <p.wilk@student.reading.ac.uk>
Date: Sat, 6 Sep 2025 12:00:02 +0100
Subject: [PATCH 1/2] bugfix/3514/build-fails-when-cache-offline

---
 src/libstore/build/substitution-goal.cc | 25 +++++++++++++++----------
 src/libstore/store-api.cc               | 22 +++++++++++++---------
 2 files changed, 28 insertions(+), 19 deletions(-)

diff --git a/src/libstore/build/substitution-goal.cc b/src/libstore/build/substitution-goal.cc
index ab95ea4a2..f47b4233d 100644
--- a/src/libstore/build/substitution-goal.cc
+++ b/src/libstore/build/substitution-goal.cc
@@ -55,9 +55,14 @@ Goal::Co PathSubstitutionGoal::init()
     auto subs = settings.useSubstitutes ? getDefaultSubstituters() : std::list<ref<Store>>();
 
     bool substituterFailed = false;
+    std::optional<Error> lastStoresException = std::nullopt;
 
     for (const auto & sub : subs) {
         trace("trying next substituter");
+        if (lastStoresException.has_value()) {
+            trace("exception from previous substituter found when creating path substitution goal");
+            trace(lastStoresException.value().message());
+        }
 
         cleanup();
 
@@ -80,19 +85,14 @@ Goal::Co PathSubstitutionGoal::init()
         try {
             // FIXME: make async
             info = sub->queryPathInfo(subPath ? *subPath : storePath);
-        } catch (InvalidPath &) {
+        } catch (InvalidPath & e) {
             continue;
         } catch (SubstituterDisabled & e) {
-            if (settings.tryFallback)
-                continue;
-            else
-                throw e;
+            continue;
         } catch (Error & e) {
-            if (settings.tryFallback) {
-                logError(e.info());
-                continue;
-            } else
-                throw e;
+            logError(e.info());
+            lastStoresException = std::make_optional(std::move(e));
+            continue;
         }
 
         if (info->path != storePath) {
@@ -147,6 +147,7 @@ Goal::Co PathSubstitutionGoal::init()
         bool out = false; // is mutated by tryToRun
         co_await tryToRun(subPath ? *subPath : storePath, sub, info, out);
         substituterFailed = substituterFailed || out;
+        lastStoresException = std::nullopt;
     }
 
     /* None left.  Terminate this goal and let someone else deal
@@ -156,6 +157,10 @@ Goal::Co PathSubstitutionGoal::init()
         worker.failedSubstitutions++;
         worker.updateProgress();
     }
+    if (lastStoresException.has_value() && !settings.tryFallback) {
+        printError("Exception left in accumulator after all stores finished");
+        throw lastStoresException.value();
+    }
 
     /* Hack: don't indicate failure if there were no substituters.
        In that case the calling derivation should just do a
diff --git a/src/libstore/store-api.cc b/src/libstore/store-api.cc
index d96be5965..ff62b10dc 100644
--- a/src/libstore/store-api.cc
+++ b/src/libstore/store-api.cc
@@ -1,3 +1,4 @@
+#include "nix/util/logging.hh"
 #include "nix/util/signature/local-keys.hh"
 #include "nix/util/source-accessor.hh"
 #include "nix/store/globals.hh"
@@ -392,12 +393,10 @@ void Store::querySubstitutablePathInfos(const StorePathCAMap & paths, Substituta
 {
     if (!settings.useSubstitutes)
         return;
-    for (auto & sub : getDefaultSubstituters()) {
-        for (auto & path : paths) {
-            if (infos.count(path.first))
-                // Choose first succeeding substituter.
-                continue;
 
+    for (auto & path : paths) {
+        std::optional<Error> lastStoresException = std::nullopt;
+        for (auto & sub : getDefaultSubstituters()) {
             auto subPath(path.first);
 
             // Recompute store path so that we can use a different store root.
@@ -437,12 +436,17 @@ void Store::querySubstitutablePathInfos(const StorePathCAMap & paths, Substituta
             } catch (InvalidPath &) {
             } catch (SubstituterDisabled &) {
             } catch (Error & e) {
-                if (settings.tryFallback)
-                    logError(e.info());
-                else
-                    throw;
+                printError(
+                    "Error in substituter while querying path info for %s:\n\"%s\"\n\nNix will now try the next substituter",
+                    sub->printStorePath(subPath),
+                    e.message());
+                lastStoresException = std::make_optional(std::move(e));
             }
         }
+        if (lastStoresException.has_value() && !settings.tryFallback) {
+            printError("Exception left in accumulator after all stores finished");
+            throw lastStoresException.value();
+        }
     }
 }
 
-- 
2.50.1

