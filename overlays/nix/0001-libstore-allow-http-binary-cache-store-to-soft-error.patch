From fcf5b71838de4d8d5b3517105b429b295171d092 Mon Sep 17 00:00:00 2001
From: Philip Wilk <p.wilk@student.reading.ac.uk>
Date: Sat, 6 Sep 2025 02:53:33 +0100
Subject: [PATCH] libstore: allow http-binary-cache-store to soft error out

---
 src/libstore/build/substitution-goal.cc | 23 ++++++++++++++---------
 src/libstore/filetransfer.cc            |  8 +++++++-
 src/libstore/http-binary-cache-store.cc | 14 ++++++++++++--
 src/libstore/store-api.cc               | 23 ++++++++++++++---------
 4 files changed, 47 insertions(+), 21 deletions(-)

diff --git a/src/libstore/build/substitution-goal.cc b/src/libstore/build/substitution-goal.cc
index ab95ea4a2..d97617636 100644
--- a/src/libstore/build/substitution-goal.cc
+++ b/src/libstore/build/substitution-goal.cc
@@ -56,7 +56,8 @@ Goal::Co PathSubstitutionGoal::init()
 
     bool substituterFailed = false;
 
-    for (const auto & sub : subs) {
+    for (auto subIt = subs.begin(); subIt != subs.end(); subIt++) {
+        auto & sub = *subIt;
         trace("trying next substituter");
 
         cleanup();
@@ -80,19 +81,23 @@ Goal::Co PathSubstitutionGoal::init()
         try {
             // FIXME: make async
             info = sub->queryPathInfo(subPath ? *subPath : storePath);
-        } catch (InvalidPath &) {
-            continue;
-        } catch (SubstituterDisabled & e) {
-            if (settings.tryFallback)
+        } catch (InvalidPath & e) {
+            if (subIt == subs.end() && !settings.tryFallback) {
+                throw e;
+            } else
                 continue;
-            else
+        } catch (SubstituterDisabled & e) {
+            if (subIt == subs.end() && !settings.tryFallback) {
                 throw e;
+            } else
+                continue;
         } catch (Error & e) {
-            if (settings.tryFallback) {
+            if (subIt == subs.end() && !settings.tryFallback) {
+                throw e;
+            } else {
                 logError(e.info());
                 continue;
-            } else
-                throw e;
+            }
         }
 
         if (info->path != storePath) {
diff --git a/src/libstore/filetransfer.cc b/src/libstore/filetransfer.cc
index 0007b9ad8..6ce3021c2 100644
--- a/src/libstore/filetransfer.cc
+++ b/src/libstore/filetransfer.cc
@@ -496,9 +496,15 @@ struct curlFileTransfer : public FileTransfer
                     // Most 4xx errors are client errors and are probably not worth retrying:
                     //   * 408 means the server timed out waiting for us, so we try again
                     err = Misc;
-                } else if (httpStatus == 501 || httpStatus == 505 || httpStatus == 511) {
+                } else if (httpStatus == 501
+                           || httpStatus == 502
+                           || httpStatus == 504
+                           || httpStatus == 505
+                           || httpStatus == 511) {
                     // Let's treat most 5xx (server) errors as transient, except for a handful:
                     //   * 501 not implemented
+                    //   * 502 the http proxy server got a bad reponse
+                    //   * 504 the http proxy server got a no response
                     //   * 505 http version not supported
                     //   * 511 we're behind a captive portal
                     err = Misc;
diff --git a/src/libstore/http-binary-cache-store.cc b/src/libstore/http-binary-cache-store.cc
index 7737389a3..e4a297207 100644
--- a/src/libstore/http-binary-cache-store.cc
+++ b/src/libstore/http-binary-cache-store.cc
@@ -96,7 +96,7 @@ protected:
     void maybeDisable()
     {
         auto state(_state.lock());
-        if (state->enabled && settings.tryFallback) {
+        if (state->enabled) {
             int t = 60;
             printError("disabling binary cache '%s' for %s seconds", config->getHumanReadableURI(), t);
             state->enabled = false;
@@ -196,8 +196,14 @@ protected:
                     try {
                         (*callbackPtr)(std::move(result.get().data));
                     } catch (FileTransferError & e) {
-                        if (e.error == FileTransfer::NotFound || e.error == FileTransfer::Forbidden)
+                        if (e.error == FileTransfer::NotFound || e.error == FileTransfer::Forbidden) {
                             return (*callbackPtr)({});
+                        }
+                        // if the server is having errors then give up on it
+                        if (e.error == FileTransfer::Misc) {
+                            maybeDisable();
+                            return (*callbackPtr)({});
+                        }
                         maybeDisable();
                         callbackPtr->rethrow();
                     } catch (...) {
@@ -219,6 +225,10 @@ protected:
         } catch (FileTransferError & e) {
             if (e.error == FileTransfer::NotFound)
                 return std::nullopt;
+            if (e.error == FileTransfer::Misc) {
+                maybeDisable();
+                return std::nullopt;
+            }
             maybeDisable();
             throw;
         }
diff --git a/src/libstore/store-api.cc b/src/libstore/store-api.cc
index d96be5965..555e60c0c 100644
--- a/src/libstore/store-api.cc
+++ b/src/libstore/store-api.cc
@@ -1,3 +1,4 @@
+#include "nix/util/logging.hh"
 #include "nix/util/signature/local-keys.hh"
 #include "nix/util/source-accessor.hh"
 #include "nix/store/globals.hh"
@@ -392,11 +393,11 @@ void Store::querySubstitutablePathInfos(const StorePathCAMap & paths, Substituta
 {
     if (!settings.useSubstitutes)
         return;
-    for (auto & sub : getDefaultSubstituters()) {
-        for (auto & path : paths) {
-            if (infos.count(path.first))
-                // Choose first succeeding substituter.
-                continue;
+
+    auto subs = getDefaultSubstituters();
+    for (auto & path : paths) {
+        for (auto subIt = subs.begin(); subIt != subs.end(); subIt++) {
+            auto & sub = *subIt;
 
             auto subPath(path.first);
 
@@ -437,10 +438,14 @@ void Store::querySubstitutablePathInfos(const StorePathCAMap & paths, Substituta
             } catch (InvalidPath &) {
             } catch (SubstituterDisabled &) {
             } catch (Error & e) {
-                if (settings.tryFallback)
-                    logError(e.info());
-                else
-                    throw;
+                if (subIt == subs.end() && !settings.tryFallback) {
+                    throw e;
+                } else {
+                    notice(
+                        "Error in substituter while querying path info for %s:\n\"%s\"\n\nNix will now try the next substituter",
+                        sub->printStorePath(subPath),
+                        e.message());
+                }
             }
         }
     }
-- 
2.50.1

